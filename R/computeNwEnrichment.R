#'Perform enrichment analysis on the input network
#'@description perform enrichment analysis from p-values of the network nodes.
#'The input network is generated from any function such as \code{\link{computeSimilarity}}, \code{\link{computeCorrelation}}, \code{\link{computeParCorrelation}}, \code{\link{computeSubnetwork}},
#'\code{\link{fetchHetNetwork}}, \code{\link{fetchHetNetworkByGID}}, \code{\link{fetchNetwork} and \code{\link{fetchNetworkByGID}}.
#'The function wraps around the main functions of \pkg{\link{piano}}.
#'@usage computeNwEnrichment(edgelist, nodelist, annotation, pval, fc, internalid, method, size)
#'@param edgelist a data frame of edges contains at least a source column (1st column) and a target column (2nd column).
#'@param nodelist a data frame of nodes contains at least two columns of node attributes.
#'1st column is id or neo4j id, 2nd column is id or grinn id. The 2nd column is used for Mesh annotation.
#'@param annotation a string specifying the annotation type e.g. pathway (default) and mesh. Pathway annotation requires the database.
#'Mesh annotation doesn't require the database but it is available for PubChem compounds only.
#'@param pval a numeric vector or a two-column data frame of statistical values e.g. p-values.
#'If \code{pval} is a vector, the name attributes must be identical to the names of network nodes.
#'If \code{pval} is a data frame, 1st column contains the network nodes and 2nd column contains statistical values.
#'@param fc a numeric vector of fold changes or sign information (positive or negative) with name attributes identical to the names of entities. Default is NULL.
#'@param internalid a logical value indicating whether the network nodes are neo4j ids, if TRUE (default). If not, the network nodes are expected to be any ids.
#'See details and see \code{\link{convertId}} for how to convert ids. It has no effect on Mesh annotation.
#'@param method a string specifying the enrichment analysis method. It can be one of reporter (default), fisher, median, mean, stouffer. See \code{\link{runGSA}}
#'@param size a numeric vector specifying the minimum and maximum number of members in each annotation term to be used in the analysis. Default is c(3,500).
#'@details The database uses two id systems. The neo4j id is a numeric, internal id automatically generated by the database system.
#'The grinn id (gid) is an id system of Grinn database that uses main ids of standard resources
#'i.e. ENSEMBL for genes (e.g.ENSG00000139618), UniProt for proteins (e.g.P0C9J6), PubChem CID for compounds (e.g.5793), KEGG for pathways (e.g.hsa00010).
#'@return list of data frame of nodes, edges, enrichment and pairs. The pairs data frame contains annotation pairs. The data frame of enrichment contains the following components:
#'
#'\code{rank} = rank sort by p
#'
#'\code{id} = annotation id or annotation neo4j id
#'
#'\code{gid} = annotation id or annotation grinn id
#'
#'\code{nodename} = annotation name
#'
#'\code{nodelabel} = annotation type
#'
#'\code{nodexref} = cross references
#'
#'\code{p} = raw p-values
#'
#'\code{p_adj} = adjusted p-values
#'
#'\code{no_of_entities} = number of input entities in each annotation term
#'
#'\code{annotation_size} = total number of entities in each annotation term from the database
#'
#'\code{member} = list of entity members of the annotation term
#'
#'Return list of empty data frame if error or found nothing.
#'@author Kwanjeera W \email{kwanich@@ucdavis.edu}
#'@references Fisher R. (1932) Statistical methods for research workers. Oliver and Boyd, Edinburgh.
#'@references Stouffer S., Suchman E., Devinney L., Star S., and Williams R. (1949) The American soldier: adjustment during army life. Princeton University Press, Oxford, England.
#'@references Patil K. and Nielsen J. (2005) Uncovering transcriptional regulation of metabolism by using metabolic network topology. Proceedings of the National Academy of Sciences of the United States of America 102(8), 2685.
#'@references Oliveira A., Patil K., and Nielsen J. (2008) Architecture of transcriptional regulatory circuits is knitted over the topology of bio-molecular interaction networks. BMC Systems Biology 2(1), 17.
#'@references VÃ¤remo L., Nielsen J., and Nookaew I. (2013) Enriching the gene set analysis of genome-wide data by incorporating directionality of gene expression and combining statistical hypotheses and methods. Nucleic Acids Research, 41(8), pp. 4378-4391.
#'@seealso \code{\link{loadGSC}}, \code{\link{runGSA}}, \code{\link{GSAsummaryTable}}
#'@examples
#'# Compute enriched Mesh terms of the input network
#'#simnw <- computeSimilarity(c(1110,10413,196,51,311,43,764,790)) #compute similarity network for given pubchem compounds
#'#pval <- data.frame(pubchem=c(1110,10413,196,51,311,43,764,790), stat=runif(8, 0, 0.06)) #statistical values of pubchem compounds
#'#result <- computeNwEnrichment(simnw$edges, simnw$nodes, annotation="mesh", pval, internalid = FALSE)
#'# Compute enriched pathways of the input network (example for mouse database only!)
#'#prt = c(217389,268332,268655,328500,335545, 282124, 266645, 356549, 269007, 284429, 334878)
#'#cmp = c(0, 2, 1, 49180, 11429, 1774, 43936)
#'#bionw <- fetchHetNetwork(from=prt, to=cmp, pattern="(from:Protein)-[:CATALYSIS]->(to:Compound)")
#'#pval <- data.frame(nid=c(0, 2, 1, 49180, 11429, 1774, 43936,217389,268332,268655,328500,335545, 282124, 266645, 356549, 269007, 284429, 334878), stat=runif(18, 0, 0.06))
#'#result <- computeNwEnrichment(bionw$edges, bionw$nodes, annotation="pathway", pval, size=c(1,100))
#'@export
computeNwEnrichment <- function(edgelist, nodelist, annotation="pathway", pval, fc=NULL, internalid = TRUE, method="reporter", size=c(3,500)) UseMethod("computeNwEnrichment")
#'@export
computeNwEnrichment.default <- function (edgelist, nodelist, annotation="pathway", pval, fc=NULL, internalid = TRUE, method="reporter", size=c(3,500)){
  out <- tryCatch(
    {
      tmparg <- try(annotation <- match.arg(tolower(annotation), c("pathway","mesh"), several.ok = FALSE), silent = TRUE)
      if (class(tmparg) == "try-error") {
        stop("argument 'annotation' is not valid, choose one from the list: pathway,mesh")
      }
      tmparg <- try(method <- match.arg(tolower(method), c("reporter","fisher","median","mean","stouffer"), several.ok = FALSE), silent = TRUE)
      if (class(tmparg) == "try-error") {
        stop("argument 'method' is not valid, choose one from the list: reporter,fisher,median,mean,stouffer")
      }
      require('dplyr')#load dplyr for opencpu
      if (class(pval) == "data.frame") {#format pval dataframe input: 1st id, 2nd pval, 3rd fc (can be NULL)
        if(internalid){#format pval: 1st id, 2nd pval, ... ,use only 1st and 2nd column
          pv = pval[,2]
          names(pv) = pval[,1]
          pval = pv
        }else{#format pval: 1st gid, 2nd pval, ... ,use only 1st and 2nd column, change gid to id
          merged = merge(nodelist, pval, by.x = colnames(nodelist)[2], by.y = colnames(pval)[1], all.y = TRUE)
          pv = merged[,ncol(nodelist)+1]
          names(pv) = merged$id
          pval = pv
        }
      }
      if(tolower(annotation) == 'pathway' && foundDb()){#pathway enrichment
        cat("Querying database ...\n")
        if(internalid){
          annols = apply(nodelist, 1, function(x) fetchNetwork(to=x["id"], fromtype="pathway", totype = x["nodelabel"], reltype = "ANNOTATION")) #query annotation pairs
        }else{
          annols = apply(nodelist, 1, function(x) fetchNetworkByGID(to=x["gid"], fromtype="pathway", totype = x["nodelabel"], reltype = "ANNOTATION")) #query annotation pairs
        }
        if(!is.null(unlist(annols))){#found annotation
          annonws = combineNetworks(annols) #combine annotation pairs
          era = computeEnrichment(edgelist = annonws$edges[,2:1], pval = pval, fc = fc, method = method, size=size, returnas="dataframe") #compute enrichment
          era = era[order(era$p),]
          era = era[ , !(colnames(era) == 'no_of_entities')] #hide sum columns
          era$rank = seq(1:nrow(era))
          era = merge(annonws$nodes, era, by='id') #merge annotation attributes and enrichemt results
          era = era[,c(ncol(era),1:(ncol(era)-1))] #rearrange columns
          #count subtotal entities
          tatt = dplyr::left_join(annonws$edges[,1:2],annonws$nodes,by=c('target'='id')) #get target attributes
          subtotls = tatt %>% dplyr::group_by(source,nodelabel) %>% dplyr::tally() #count entities
          subtot = plyr::ddply(subtotls,c('source'),plyr::summarise,no_of_entities=list(paste0(nodelabel,' (',n,')')))
          era = dplyr::left_join(era, subtot, by=c('id'='source'))
          #count total entities
          ptwstat = apply(era, 1, function(x){
            ntypels = subtotls[subtotls$source == x$id,] #get nodetype
            apply(ntypels, 1, function(y){
              qstring = paste0('MATCH (from:Pathway)-[r:ANNOTATION]->(to:',y[2],') where ID(from) = ',x$id,' RETURN toString(ID(from)), labels(to), count(to)')
              annosize = as.data.frame(curlRequest.TRANSACTION.row(qstring)[[1]]$row, col.names = c('id','nodelabel','count'), stringsAsFactors = FALSE) #get annotation info from db
              annosize
            })
          })
          ptwstat = plyr::ldply(unlist(ptwstat, recursive = F), data.frame) #get total number of annotated nodes of a pathway
          ptwstat = ptwstat[order(ptwstat$nodelabel),]
          tot = plyr::ddply(ptwstat,c('id'),plyr::summarise,annotation_size=list(paste0(nodelabel,' (',count,')')))
          era = dplyr::left_join(era,tot,by=c('id'='id'))
          era = era[c(1:(ncol(era)-3),(ncol(era)-1),ncol(era),(ncol(era)-2))] #rearrange columns
          list(nodes=nodelist, edges=edgelist, enrichment=era, pairs=annonws$edges) #output
        }
        else{#no annotation found
          list(nodes=data.frame(), edges=data.frame(), enrichment=data.frame(), pairs=data.frame()) #output
        }
      }else if(tolower(annotation) == 'mesh'){#mesh enrichment
        cat("Connecting PubChem ...\n")
        annols = apply(nodelist, 1, function(x) callMesh(pcid=x["gid"])) #query pubchem annotation pairs
        if(!is.null(unlist(annols))){#found annotation
          annonws = combineNetworks(annols) #combine annotation pairs
          #format edge, change gid to id, fix edge row order
          annopair = dplyr::right_join(nodelist[,1:2],annonws$edges[,1:2],by=c('gid' = 'target'))[,c(3,1)]
          colnames(annopair) = c('source','target')
          era = computeEnrichment(edgelist = annopair[,2:1], pval = pval, fc = fc, method = method, size=size, returnas="dataframe") #compute enrichment
          era = era[order(era$p),]
          era$rank = seq(1:nrow(era))
          era = merge(annonws$nodes[,1:6], era, by='id') #merge annotation attributes and enrichemt results
          era = era[,c(ncol(era),1:(ncol(era)-6),(ncol(era)-3),(ncol(era)-2),(ncol(era)-4),(ncol(era)-5),(ncol(era)-1))] #rearrange columns
          list(nodes=nodelist, edges=edgelist, enrichment=era, pairs=annopair) #output
        }
        else{#no annotation found
          list(nodes=data.frame(), edges=data.frame(), enrichment=data.frame(), pairs=data.frame()) #output
        }
      }else{
        cat('Error: No database installed, returning no data ..\n')
        list(nodes=data.frame(), edges=data.frame(), enrichment=data.frame(), pairs=data.frame()) #output
      }
    },error=function(e) {
      message(e)
      cat("\nError: RETURN no data ..\n")
      list(nodes=data.frame(), edges=data.frame(), enrichment=data.frame(), pairs=data.frame()) #output
    })
  return(out)
}
